<!DOCTYPE html>
<html>
  <head>
    <title>A-Frame / WebXR / AR / Hit Test with Hand Tracking</title>
    <meta name="description" content="Hello, WebVR! - A-Frame">
    <script src='./aframe-master.js'></script>
    <script src='./three.xr.js'></script>
    <script src='./aframe-xr.js'></script>
    <script src='./hit-test.js'></script>
    <!-- Add MediaPipe libraries -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.3.1620248257/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1620248257/camera_utils.js" crossorigin="anonymous"></script>
    <style>
      body { margin: 0; overflow: hidden; touch-action: none; }
      video { display: none; }  /* Hide video completely */
      canvas#output_canvas { 
        position: fixed; 
        top: 0; 
        left: 0; 
        width: 100vw; 
        height: 100vh;
        pointer-events: none;
        z-index: 999;
        background: transparent;  /* Make canvas background transparent */
      }
        body { margin: 0; overflow: hidden; touch-action: none; }
        video { display: none; }  /* Hide video completely */
        canvas#output_canvas { 
          position: fixed; 
          top: 0; 
          left: 0; 
          width: 100vw; 
          height: 100vh;
          pointer-events: none;
          z-index: 999;
          background: transparent;  /* Make canvas background transparent */
        }
          #modelSwitcher {
            position: fixed;
            bottom: 80px; /* Posisi di atas status indicator */
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            background: rgba(0,0,0,0.5);
            color: white;
            border: none;
            border-radius: 5px;
            z-index: 1000;
            cursor: pointer;
            pointer-events: auto; /* Pastikan tombol bisa diklik */
          }
      
          #reticle {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 50px;
            height: 50px;
            pointer-events: none;
            z-index: 998;
          }
      
          .reticle-circle {
            position: absolute;
            width: 100%;
            height: 100%;
            border: 2px solid white;
            border-radius: 50%;
            animation: pulse 2s infinite;
          }
      
          .reticle-arrow {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            border-left: 3px solid white;
            border-bottom: 3px solid white;
            transform: translate(-50%, -25%) rotate(-45deg);
          }
      
          @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.5; }
            100% { transform: scale(1); opacity: 1; }
          }
    </style>
    <style>
        body { margin: 0; overflow: hidden; touch-action: none; }
        video { display: none; }  /* Hide video completely */
        canvas#output_canvas { 
          position: fixed; 
          top: 0; 
          left: 0; 
          width: 100vw; 
          height: 100vh;
          pointer-events: none;
          z-index: 999;
          background: transparent;  /* Make canvas background transparent */
        }
          #modelSwitcher {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            background: rgba(0,0,0,0.5);
            color: white;
            border: none;
            border-radius: 5px;
            z-index: 1000;
            pointer-events: all;
            touch-action: none; /* Mencegah event touch default */
          }
      
          .hit-test-area {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: calc(100% - 120px); /* Area di atas tombol */
            pointer-events: all;
          }
    </style>
  </head>
  <body>
    <!-- Add this after video element -->
    <div class="hit-test-area"></div>
        <button id="modelSwitcher">Switch Model</button>
        <div id="reticle">
          <div class="reticle-circle"></div>
          <div class="reticle-arrow"></div>
        </div>
    <video id="video" autoplay playsinline></video>
    <canvas id="output_canvas"></canvas>
    <a-scene hit-test="doHitTest: true; hitTestNoAnchor: true" embedded>
      <a-assets timeout="10000">
        <a-asset-item id="model1" src="./model1.glb"></a-asset-item>
        <a-asset-item id="model2" src="./model2.glb"></a-asset-item>
        <a-asset-item id="model3" src="./model3.glb"></a-asset-item>
        <a-asset-item id="model4" src="./model4.glb"></a-asset-item>
        <a-asset-item id="model5" src="./model5.glb"></a-asset-item>
        <a-asset-item id="model6" src="./model6.glb"></a-asset-item>
        <a-asset-item id="model7" src="./model7.glb"></a-asset-item>
      </a-assets>
      <!-- Add camera entity for AR -->
      <a-entity camera position="0 1.6 0"></a-entity>
    </a-scene>
    <!-- Remove duplicate script tag -->
    <!-- <script src="./hand-tracking.js"></script> -->
    <!-- Hapus script tag yang kedua dan gabungkan semua kode ke dalam script tag pertama -->
    <script>
      var scene = AFRAME.scenes[0];
      var currentModelIndex = 0;
      var currentEntity = null;
      const models = ['#model1', '#model2', '#model3', '#model4', '#model5', '#model6', '#model7'];
      let arSessionActive = false;
      let handTrackingActive = false;
      let previousLandmarks = null;
      let previousScale = null;
      let initialARPosition = null;
      let initialARRotation = null;
      let initialARScale = null;

      const videoElement = document.getElementById('video');
      const canvasElement = document.getElementById('output_canvas');
      const canvasCtx = canvasElement.getContext('2d');

      // Status indicator setup
      const statusDiv = document.createElement('div');
      statusDiv.style.position = 'fixed';
      statusDiv.style.bottom = '20px';
      statusDiv.style.left = '20px';
      statusDiv.style.color = 'white';
      statusDiv.style.backgroundColor = 'rgba(0,0,0,0.5)';
      statusDiv.style.padding = '10px';
      statusDiv.style.zIndex = '999';
      document.body.appendChild(statusDiv);

      function lerp(a, b, t) {
          return a * (1 - t) + b * t;
      }

      function smoothLandmarks(landmarks) {
          if (!previousLandmarks) {
              previousLandmarks = landmarks;
              return landmarks;
          }

          const smoothedLandmarks = landmarks.map((landmark, index) => {
              const previousLandmark = previousLandmarks[index];
              if (!previousLandmark) return landmark;

              const smoothedX = landmark.x * 0.3 + previousLandmark.x * 0.7;
              const smoothedY = landmark.y * 0.3 + previousLandmark.y * 0.7;
              const smoothedZ = landmark.z * 0.3 + previousLandmark.z * 0.7;

              return { x: smoothedX, y: smoothedY, z: smoothedZ };
          });

          previousLandmarks = smoothedLandmarks;
          return smoothedLandmarks;
      }

      function updateObjectTransform(indexFinger, thumb) {
          if (!initialARPosition || !initialARRotation || !initialARScale) return;

          const distance = Math.sqrt(
              Math.pow(indexFinger.x - thumb.x, 2) + 
              Math.pow(indexFinger.y - thumb.y, 2)
          );

          const baseScale = 0.1;
          const scaleFactor = Math.min(distance * 2, 3.0); // Limit maximum scale
          const newScale = baseScale * scaleFactor;
          
          const smoothedScale = lerp(previousScale || newScale, newScale, 0.1); // Slower smoothing
          previousScale = smoothedScale;
          
          const deltaX = thumb.x - indexFinger.x;
          const deltaY = thumb.y - indexFinger.y;
          const deltaZ = thumb.z - indexFinger.z;

          const rotationX = Math.atan2(deltaY, deltaZ) * (180 / Math.PI);
          const rotationY = Math.atan2(deltaX, deltaZ) * (180 / Math.PI);
          
          // Apply rotation limits
          const limitedRotationX = Math.max(-90, Math.min(90, rotationX));
          const limitedRotationY = Math.max(-90, Math.min(90, rotationY));
          
          currentEntity.setAttribute('rotation', `${limitedRotationX} ${limitedRotationY} 0`);
          currentEntity.setAttribute('scale', `${smoothedScale} ${smoothedScale} ${smoothedScale}`);
      }

      function onResults(results) {
          if (!arSessionActive || !handTrackingActive || !currentEntity) return;
          
          canvasCtx.save();
          canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

          if (results.multiHandLandmarks) {
              for (const landmarks of results.multiHandLandmarks) {
                  const smoothedLandmarks = smoothLandmarks(landmarks);
                  drawConnectors(canvasCtx, smoothedLandmarks, HAND_CONNECTIONS, 
                      { color: '#00FF00', lineWidth: 2 });
                  drawLandmarks(canvasCtx, smoothedLandmarks, 
                      { color: '#FF0000', lineWidth: 1 });

                  if (smoothedLandmarks[8] && smoothedLandmarks[4]) {
                      updateObjectTransform(smoothedLandmarks[8], smoothedLandmarks[4]);
                  }
              }
          }
          canvasCtx.restore();
      }

      let handTracker = null;

      function initializeHandTracking() {
          if (handTracker) {
              handTracker.close();
              handTracker = null;
          }

          handTracker = new Hands({
              locateFile: (file) => {
                  return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/${file}`;
              }
          });

          handTracker.setOptions({
              maxNumHands: 1,
              modelComplexity: 1,
              minDetectionConfidence: 0.5,
              minTrackingConfidence: 0.5,
              selfieMode: false
          });

          handTracker.onResults(onResults);

          const camera = new Camera(videoElement, {
              onFrame: async () => {
                  if (handTrackingActive) {
                      try {
                          await handTracker.send({image: videoElement});
                      } catch (error) {
                          console.error('Hand tracking error:', error);
                      }
                  }
              },
              width: 640,
              height: 480,
              facingMode: 'environment'
          });

          camera.start()
              .then(() => {
                  console.log('Camera started');
                  statusDiv.textContent = "Hand tracking active";
              })
              .catch(error => {
                  console.error('Camera error:', error);
                  statusDiv.textContent = "Camera error: " + error.message;
              });
      }

      // Hapus variabel reticle
      // const reticle = document.getElementById('reticle');
      
      // Update event listener hit-test
      scene.addEventListener('ar-hit-test-achieved', (evt) => {
          console.log('Hit test berhasil:', evt.detail);
          hitTestPosition = evt.detail;
          statusDiv.textContent = "Permukaan terdeteksi. Tap untuk menempatkan objek.";
      });
      
      // Update fungsi newObject
      function newObject(data) {
          if (!data.detail || !data.detail.position) {
              console.error('Invalid position data:', data);
              return;
          }

          if (currentEntity) {
              currentEntity.parentNode.removeChild(currentEntity);
          }

          var entity = document.createElement('a-entity');
          entity.setAttribute('gltf-model', models[currentModelIndex]);
          entity.setAttribute('scale', '0.1 0.1 0.1');
          entity.setAttribute('shadow', 'cast: true; receive: true');
          entity.setAttribute('position', data.detail.position);
          entity.setAttribute('class', 'clickable');
          
          scene.appendChild(entity);
          currentEntity = entity;
          
          initialARPosition = data.detail.position;
          initialARRotation = entity.getAttribute('rotation');
          initialARScale = entity.getAttribute('scale');
          
          previousScale = null;
          previousLandmarks = null;
          
          statusDiv.textContent = `Model ${currentModelIndex + 1} ditempatkan. Gunakan gerakan tangan untuk mengontrol.`;
      }

      scene.addEventListener('enter-vr', function () {
          console.log("AR session started");
          arSessionActive = true;
          statusDiv.textContent = "AR active. Looking for surface...";
          canvasElement.style.display = "block";
          canvasElement.style.opacity = "1";
          
          setTimeout(() => {
              handTrackingActive = true;
              initializeHandTracking();
              console.log("Hand tracking initialized");
          }, 2000);
      });

      scene.addEventListener('exit-vr', function () {
          console.log("AR session ended");
          arSessionActive = false;
          handTrackingActive = false;
          statusDiv.textContent = "AR session ended";
          canvasElement.style.display = "none";
          
          if (videoElement.srcObject) {
              videoElement.srcObject.getTracks().forEach(track => track.stop());
              videoElement.srcObject = null;
          }
      });

      // Add after variable declarations
      const modelSwitcher = document.getElementById('modelSwitcher');
      modelSwitcher.addEventListener('click', (event) => {
          event.stopPropagation(); // Hentikan event bubbling
          currentModelIndex = (currentModelIndex + 1) % models.length;
          if (currentEntity) {
              currentEntity.setAttribute('gltf-model', models[currentModelIndex]);
              statusDiv.textContent = `Model ${currentModelIndex + 1} dipilih`;
          }
      });

      // Tambahkan variabel untuk menyimpan posisi hit-test
      let hitTestPosition = null;

      // Tambahkan event listener untuk hit-test
      scene.addEventListener('newAnchoredEntity', newObject);

      // Update event listener hit-test
      scene.addEventListener('ar-hit-test-achieved', (evt) => {
          console.log('Hit test berhasil:', evt.detail);
          hitTestPosition = evt.detail;
          
          // Update posisi reticle menggunakan koordinat dunia
          if (reticle) {
              const worldPosition = evt.detail.worldPosition;
              reticle.style.display = 'block';
              
              // Konversi posisi dunia ke koordinat layar
              const tempVector = new THREE.Vector3(
                  worldPosition.x,
                  worldPosition.y,
                  worldPosition.z
              );
              
              // Dapatkan kamera dari scene
              const camera = document.querySelector('[camera]').object3D;
              tempVector.project(camera);
              
              const x = (tempVector.x + 1) / 2 * window.innerWidth;
              const y = (-tempVector.y + 1) / 2 * window.innerHeight;
              
              reticle.style.transform = `translate(${x}px, ${y}px)`;
              reticle.style.opacity = "1";
          }
          statusDiv.textContent = "Permukaan terdeteksi. Tap untuk menempatkan objek.";
      });

      // Update fungsi newObject
      function newObject(data) {
          if (currentEntity) {
              scene.removeChild(currentEntity);
          }

          var entity = document.createElement('a-entity');
          entity.setAttribute('gltf-model', models[currentModelIndex]);
          entity.setAttribute('scale', '0.1 0.1 0.1');
          entity.setAttribute('shadow', 'cast: true; receive: true');
          entity.setAttribute('position', data.detail.position);
          entity.setAttribute('class', 'clickable');
          
          scene.appendChild(entity);
          currentEntity = entity;
          
          initialARPosition = entity.getAttribute('position');
          initialARRotation = entity.getAttribute('rotation');
          initialARScale = entity.getAttribute('scale');
          
          previousScale = null;
          previousLandmarks = null;

          // Sembunyikan reticle setelah objek ditempatkan
          reticle.style.display = 'none';
          
          statusDiv.textContent = `Model ${currentModelIndex + 1} ditempatkan. Gunakan gerakan tangan untuk mengontrol.`;
      }

      // Update event listener untuk tombol switch agar tidak mengganggu hit-test:
      modelSwitcher.addEventListener('click', (event) => {
          event.preventDefault();
          event.stopPropagation();
          currentModelIndex = (currentModelIndex + 1) % models.length;
          if (currentEntity) {
              currentEntity.setAttribute('gltf-model', models[currentModelIndex]);
              statusDiv.textContent = `Model ${currentModelIndex + 1} dipilih`;
          }
          return false;
      });

      scene.addEventListener('ar-hit-test-failed', () => {
          console.log('Hit test gagal');
          statusDiv.textContent = "Tidak dapat menemukan permukaan. Coba arahkan ke permukaan datar.";
          reticle.style.opacity = "0.5"; // Redup reticle
      });
      scene.addEventListener('ar-hit-test-start', () => {
          statusDiv.textContent = "Looking for surface...";
      });

      function adjustVideoCanvasSize() {
          const width = window.innerWidth;
          const height = window.innerHeight;
          
          canvasElement.style.width = width + 'px';
          canvasElement.style.height = height + 'px';
          canvasElement.width = width;
          canvasElement.height = height;
          
          videoElement.style.width = width + 'px';
          videoElement.style.height = height + 'px';
          videoElement.width = width;
          videoElement.height = height;
      }

      window.addEventListener('resize', adjustVideoCanvasSize);
      adjustVideoCanvasSize();
    </script>
  </body>
</html>


