<!DOCTYPE html>
<html>
  <head>
    <title>A-Frame / WebXR / AR / Hit Test with Hand Tracking</title>
    <meta name="description" content="WebAR with Hand Tracking">
    <script src="./aframe-master.js"></script>
    <script src="./three.xr.js"></script>
    <script src="./aframe-xr.js"></script>
    <script src="./hit-test.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.3.1620248257/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1620248257/camera_utils.js"></script>
    <style>
      body { margin: 0; overflow: hidden; touch-action: none; }
      video { display: none; }
      canvas#output_canvas {
        position: fixed;
        top: 0; left: 0;
        width: 100vw; height: 100vh;
        pointer-events: none;
        z-index: 999;
        background: transparent;
      }
      #modelSwitcher {
        position: fixed;
        bottom: 80px;
        left: 50%;
        transform: translateX(-50%);
        padding: 10px 20px;
        background: rgba(0,0,0,0.5);
        color: white;
        border: none;
        border-radius: 5px;
        z-index: 1000;
        pointer-events: auto;
      }
      .hit-test-area {
        position: fixed;
        top: 0; left: 0;
        width: 100%;
        height: calc(100% - 120px);
        pointer-events: all;
      }
    </style>
  </head>
  <body>
    <div class="hit-test-area"></div>
    <button id="modelSwitcher">Switch Model</button>
    <video id="video" autoplay playsinline></video>
    <canvas id="output_canvas"></canvas>

    <a-scene
      hit-test="doHitTest: true; hitTestNoAnchor: true"
      cursor="rayOrigin: mouse; fuse: false"
      raycaster="objects: .clickable"
      embedded
    >
      <a-assets timeout="10000">
        <a-asset-item id="model1" src="./model1.glb"></a-asset-item>
        <a-asset-item id="model2" src="./model2.glb"></a-asset-item>
        <a-asset-item id="model3" src="./model3.glb"></a-asset-item>
        <a-asset-item id="model4" src="./model4.glb"></a-asset-item>
        <a-asset-item id="model5" src="./model5.glb"></a-asset-item>
        <a-asset-item id="model6" src="./model6.glb"></a-asset-item>
        <a-asset-item id="model7" src="./model7.glb"></a-asset-item>
      </a-assets>
      <a-entity camera position="0 1.6 0"></a-entity>
    </a-scene>

    <script>
      const scene = AFRAME.scenes[0];
      const videoElement = document.getElementById('video');
      const canvasElement = document.getElementById('output_canvas');
      const canvasCtx = canvasElement.getContext('2d');
      const modelSwitcher = document.getElementById('modelSwitcher');
      const models = ['#model1', '#model2', '#model3', '#model4', '#model5', '#model6', '#model7'];

      let currentModelIndex = 0;
      let currentEntity = null;
      let arSessionActive = false;
      let handTrackingActive = false;
      let previousLandmarks = null;
      let previousScale = null;
      let hitTestPosition = null;
      let initialARPosition = null;
      let initialARRotation = null;
      let initialARScale = null;
      let handTracker = null;
      let isModelPlaced = false;

      const statusDiv = document.createElement('div');
      statusDiv.style.cssText = 'position:fixed;bottom:20px;left:20px;color:white;background:rgba(0,0,0,0.5);padding:10px;z-index:999;';
      document.body.appendChild(statusDiv);

      function lerp(a, b, t) {
        return a * (1 - t) + b * t;
      }

      function smoothLandmarks(landmarks) {
        if (!previousLandmarks) {
          previousLandmarks = landmarks;
          return landmarks;
        }
        return landmarks.map((lm, i) => {
          const prev = previousLandmarks[i] || lm;
          return {
            x: lm.x * 0.3 + prev.x * 0.7,
            y: lm.y * 0.3 + prev.y * 0.7,
            z: lm.z * 0.3 + prev.z * 0.7
          };
        });
      }

      function updateObjectTransform(indexFinger, thumb) {
        if (!initialARPosition || !initialARRotation || !initialARScale) return;
        const distance = Math.hypot(indexFinger.x - thumb.x, indexFinger.y - thumb.y);
        const scaleFactor = Math.min(distance * 2, 3.0);
        const newScale = 0.1 * scaleFactor;
        const smoothedScale = lerp(previousScale || newScale, newScale, 0.1);
        previousScale = smoothedScale;

        const dx = thumb.x - indexFinger.x;
        const dy = thumb.y - indexFinger.y;
        const dz = thumb.z - indexFinger.z;
        const rx = Math.max(-90, Math.min(90, Math.atan2(dy, dz) * 180 / Math.PI));
        const ry = Math.max(-90, Math.min(90, Math.atan2(dx, dz) * 180 / Math.PI));

        currentEntity.setAttribute('rotation', `${rx} ${ry} 0`);
        currentEntity.setAttribute('scale', `${smoothedScale} ${smoothedScale} ${smoothedScale}`);
      }

      function onResults(results) {
        if (!arSessionActive || !handTrackingActive || !currentEntity) return;
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        if (results.multiHandLandmarks) {
          for (const landmarks of results.multiHandLandmarks) {
            const smoothed = smoothLandmarks(landmarks);
            drawConnectors(canvasCtx, smoothed, HAND_CONNECTIONS, { color: '#00FF00', lineWidth: 2 });
            drawLandmarks(canvasCtx, smoothed, { color: '#FF0000', lineWidth: 1 });
            if (smoothed[8] && smoothed[4]) {
              updateObjectTransform(smoothed[8], smoothed[4]);
            }
          }
        }
      }

      function initializeHandTracking() {
        if (handTracker) handTracker.close();
        handTracker = new Hands({
          locateFile: file => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/${file}`
        });
        handTracker.setOptions({
          maxNumHands: 1,
          modelComplexity: 1,
          minDetectionConfidence: 0.5,
          minTrackingConfidence: 0.5,
          selfieMode: false
        });
        handTracker.onResults(onResults);

        const camera = new Camera(videoElement, {
          onFrame: async () => {
            if (handTrackingActive) await handTracker.send({ image: videoElement });
          },
          width: 640,
          height: 480,
          facingMode: 'environment'
        });
        camera.start().then(() => {
          statusDiv.textContent = "Hand tracking active";
        }).catch(err => {
          statusDiv.textContent = "Camera error: " + err.message;
        });
      }

      async function initXRSession() {
        try {
          if (!navigator.xr) throw new Error("WebXR tidak tersedia");
          const supported = await navigator.xr.isSessionSupported('immersive-ar');
          if (!supported) throw new Error("AR tidak didukung");

          const session = await navigator.xr.requestSession('immersive-ar', {
            requiredFeatures: ['hit-test', 'local-floor'],
            optionalFeatures: ['dom-overlay'],
            domOverlay: { root: document.body }
          });

          const gl = document.createElement('canvas').getContext('webgl', { xrCompatible: true });
          await gl.makeXRCompatible();
          const glLayer = new XRWebGLLayer(session, gl);
          await session.updateRenderState({ baseLayer: glLayer });

          const refSpace = await session.requestReferenceSpace('local-floor');
          const viewerSpace = await session.requestReferenceSpace('viewer');
          const hitTestSource = await session.requestHitTestSource({ space: viewerSpace });

          session.requestAnimationFrame(function onXRFrame(time, frame) {
            session.requestAnimationFrame(onXRFrame);
            const pose = frame.getViewerPose(refSpace);
            if (pose) {
              const results = frame.getHitTestResults(hitTestSource);
              if (results.length > 0) {
                const hit = results[0];
                const pos = hit.getPose(refSpace).transform.position;
                hitTestPosition = { x: pos.x, y: pos.y, z: pos.z };
                statusDiv.textContent = "Permukaan ditemukan, ketuk untuk menempatkan objek.";
              }
            }
          });

          return true;
        } catch (error) {
          statusDiv.textContent = "XR Session Error: " + error.message;
          return false;
        }
      }

      scene.addEventListener('enter-vr', async () => {
        arSessionActive = await initXRSession();
        if (arSessionActive) {
          canvasElement.style.display = "block";
          statusDiv.textContent = "AR aktif. Mencari permukaan...";
        }
      });

      scene.addEventListener('click', () => {
        if (!isModelPlaced && hitTestPosition) {
          const entity = document.createElement('a-entity');
          entity.setAttribute('gltf-model', models[currentModelIndex]);
          entity.setAttribute('scale', '0.1 0.1 0.1');
          entity.setAttribute('position', hitTestPosition);
          entity.setAttribute('class', 'clickable');
          scene.appendChild(entity);

          currentEntity = entity;
          initialARPosition = hitTestPosition;
          initialARRotation = entity.getAttribute('rotation');
          initialARScale = entity.getAttribute('scale');
          previousScale = null;
          previousLandmarks = null;
          isModelPlaced = true;

          initializeHandTracking();
        }
      });

      modelSwitcher.addEventListener('click', (e) => {
        e.stopPropagation();
        currentModelIndex = (currentModelIndex + 1) % models.length;
        if (currentEntity) {
          currentEntity.setAttribute('gltf-model', models[currentModelIndex]);
          statusDiv.textContent = `Model ${currentModelIndex + 1} dipilih.`;
        }
      });
    </script>
  </body>
</html>


