<!DOCTYPE html>
<html>
  <head>
    <title>A-Frame / WebXR / AR / Hit Test with Hand Tracking</title>
    <meta name="description" content="Hello, WebVR! - A-Frame">
    <script src='./aframe-master.js'></script>
    <script src='./three.xr.js'></script>
    <script src='./aframe-xr.js'></script>
    <script src='./hit-test.js'></script>
    <!-- Add MediaPipe libraries -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <style>
      body { margin: 0; overflow: hidden; touch-action: none; }
      video { display: none; }  /* Hide video completely */
      canvas#output_canvas { 
        position: fixed; 
        top: 0; 
        left: 0; 
        width: 100vw; 
        height: 100vh;
        pointer-events: none;
        z-index: 999;
        background: transparent;  /* Make canvas background transparent */
      }
    </style>
  </head>
  <body>
    <video id="video" autoplay playsinline></video>
    <canvas id="output_canvas"></canvas>
    <a-scene hit-test embedded>
      <a-assets timeout="10000">
        <a-asset-item id="model1" src="./model1.glb"></a-asset-item>
        <a-asset-item id="model2" src="./model2.glb"></a-asset-item>
        <a-asset-item id="model3" src="./model3.glb"></a-asset-item>
        <a-asset-item id="model4" src="./model4.glb"></a-asset-item>
        <a-asset-item id="model5" src="./model5.glb"></a-asset-item>
        <a-asset-item id="model6" src="./model6.glb"></a-asset-item>
        <a-asset-item id="model7" src="./model7.glb"></a-asset-item>
      </a-assets>
      <!-- Add camera entity for AR -->
      <a-entity camera position="0 1.6 0"></a-entity>
    </a-scene>
    <!-- Remove duplicate script tag -->
    <!-- <script src="./hand-tracking.js"></script> -->
    <!-- Hapus script tag yang kedua dan gabungkan semua kode ke dalam script tag pertama -->
    <script>
      var scene = AFRAME.scenes[0];
      var currentModelIndex = 0;
      var currentEntity = null;
      const models = ['#model1', '#model2', '#model3', '#model4', '#model5', '#model6', '#model7'];
      let arSessionActive = false;
      let handTrackingActive = false;
      let previousLandmarks = null;
      let previousScale = null;
      let initialARPosition = null;
      let initialARRotation = null;
      let initialARScale = null;

      const videoElement = document.getElementById('video');
      const canvasElement = document.getElementById('output_canvas');
      const canvasCtx = canvasElement.getContext('2d');

      // Status indicator setup
      const statusDiv = document.createElement('div');
      statusDiv.style.position = 'fixed';
      statusDiv.style.bottom = '20px';
      statusDiv.style.left = '20px';
      statusDiv.style.color = 'white';
      statusDiv.style.backgroundColor = 'rgba(0,0,0,0.5)';
      statusDiv.style.padding = '10px';
      statusDiv.style.zIndex = '999';
      document.body.appendChild(statusDiv);

      function lerp(a, b, t) {
          return a * (1 - t) + b * t;
      }

      function smoothLandmarks(landmarks) {
          if (!previousLandmarks) {
              previousLandmarks = landmarks;
              return landmarks;
          }

          const smoothedLandmarks = landmarks.map((landmark, index) => {
              const previousLandmark = previousLandmarks[index];
              if (!previousLandmark) return landmark;

              const smoothedX = landmark.x * 0.3 + previousLandmark.x * 0.7;
              const smoothedY = landmark.y * 0.3 + previousLandmark.y * 0.7;
              const smoothedZ = landmark.z * 0.3 + previousLandmark.z * 0.7;

              return { x: smoothedX, y: smoothedY, z: smoothedZ };
          });

          previousLandmarks = smoothedLandmarks;
          return smoothedLandmarks;
      }

      function updateObjectTransform(indexFinger, thumb) {
          if (!initialARPosition || !initialARRotation || !initialARScale) return;

          const distance = Math.sqrt(
              Math.pow(indexFinger.x - thumb.x, 2) + 
              Math.pow(indexFinger.y - thumb.y, 2)
          );

          const baseScale = 0.1;
          const scaleFactor = distance * 2;
          const newScale = baseScale * scaleFactor;
          
          const smoothedScale = lerp(previousScale || newScale, newScale, 0.2);
          previousScale = smoothedScale;
          
          const deltaX = thumb.x - indexFinger.x;
          const deltaY = thumb.y - indexFinger.y;
          const deltaZ = thumb.z - indexFinger.z;

          const rotationX = Math.atan2(deltaY, deltaZ) * (180 / Math.PI);
          const rotationY = Math.atan2(deltaX, deltaZ) * (180 / Math.PI);
          
          currentEntity.setAttribute('rotation', `${rotationX} ${rotationY} 0`);
          currentEntity.setAttribute('scale', `${smoothedScale} ${smoothedScale} ${smoothedScale}`);
      }

      function onResults(results) {
          if (!arSessionActive || !handTrackingActive || !currentEntity) return;
          
          canvasCtx.save();
          canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

          if (results.multiHandLandmarks) {
              for (const landmarks of results.multiHandLandmarks) {
                  const smoothedLandmarks = smoothLandmarks(landmarks);
                  drawConnectors(canvasCtx, smoothedLandmarks, HAND_CONNECTIONS, 
                      { color: '#00FF00', lineWidth: 2 });
                  drawLandmarks(canvasCtx, smoothedLandmarks, 
                      { color: '#FF0000', lineWidth: 1 });

                  if (smoothedLandmarks[8] && smoothedLandmarks[4]) {
                      updateObjectTransform(smoothedLandmarks[8], smoothedLandmarks[4]);
                  }
              }
          }
          canvasCtx.restore();
      }

      function initializeHandTracking() {
          const hands = new Hands({
              locateFile: (file) => {
                  return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
              }
          });

          hands.setOptions({
              maxNumHands: 1,
              modelComplexity: 1,
              minDetectionConfidence: 0.3, // Turunkan threshold untuk deteksi lebih sensitif
              minTrackingConfidence: 0.3
          });

          hands.onResults(onResults);

          // Perbaikan akses kamera
          if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
              navigator.mediaDevices.getUserMedia({
                  video: {
                      facingMode: { exact: "environment" }, // Pastikan menggunakan kamera belakang
                      width: { ideal: 1280 },
                      height: { ideal: 720 }
                  }
              }).then(stream => {
                  videoElement.srcObject = stream;
                  videoElement.onloadedmetadata = () => {
                      videoElement.play();
                      // Mulai loop tracking
                      const processVideo = async () => {
                          if (handTrackingActive && videoElement.readyState === 4) {
                              try {
                                  await hands.send({ image: videoElement });
                              } catch (error) {
                                  console.error("Hand tracking error:", error);
                              }
                          }
                          requestAnimationFrame(processVideo);
                      };
                      processVideo();
                  };
              }).catch(err => {
                  console.error("Camera access error:", err);
                  statusDiv.textContent = "Camera error: " + err.message;
              });
          }
      }

      // Perbaikan event listener enter-vr
      scene.addEventListener('enter-vr', function () {
          console.log("AR session started");
          arSessionActive = true;
          statusDiv.textContent = "AR active. Looking for surface...";
          canvasElement.style.display = "block"; // Pastikan canvas terlihat
          canvasElement.style.opacity = "1";
          
          // Mulai hand tracking dengan delay lebih lama
          setTimeout(() => {
              if (!handTrackingActive) {
                  handTrackingActive = true;
                  initializeHandTracking();
                  console.log("Hand tracking initialized");
              }
          }, 2000); // Tambah delay menjadi 2 detik
      });

      // Perbaikan exit-vr
      scene.addEventListener('exit-vr', function () {
          arSessionActive = false;
          handTrackingActive = false;
          statusDiv.textContent = "AR session ended";
          canvasElement.style.display = "none"; // Sembunyikan canvas saat keluar
          
          // Hentikan video stream
          if (videoElement.srcObject) {
              const tracks = videoElement.srcObject.getTracks();
              tracks.forEach(track => track.stop());
              videoElement.srcObject = null;
          }
      });

      var modelAsset = document.querySelector('#model1');
      modelAsset.addEventListener('error', function(e) {
          console.error('Error loading model:', e);
          createFallbackObject();
      });

      function createFallbackObject(data) {
          if (currentEntity) {
              scene.removeChild(currentEntity);
          }

          var entity = data.detail;
          entity.setAttribute('geometry', {
              primitive: 'box',
              width: 0.1,
              height: 0.1,
              depth: 0.1
          });
          entity.setAttribute('material', {
              color: 'red'
          });
          scene.appendChild(entity);
          currentEntity = entity;
      }

      var newObject = function(data) {
          if (currentEntity) {
              scene.removeChild(currentEntity);
          }

          var entity = data.detail;
          entity.setAttribute('gltf-model', models[currentModelIndex]);
          entity.setAttribute('scale', '0.1 0.1 0.1');
          entity.setAttribute('material', {
              shader: 'standard',
              fog: false
          });     

          scene.appendChild(entity);
          currentEntity = entity;
          
          initialARPosition = entity.getAttribute('position');
          initialARRotation = entity.getAttribute('rotation');
          initialARScale = entity.getAttribute('scale');
          
          currentModelIndex = (currentModelIndex + 1) % models.length;
      }

      scene.addEventListener('newAnchoredEntity', newObject);

      // Event Listeners for AR
      scene.addEventListener('enter-vr', function () {
          console.log("AR session started");
          arSessionActive = true;
          statusDiv.textContent = "AR active. Looking for surface...";
          
          if (!handTrackingActive) {
              handTrackingActive = true;
              initializeHandTracking();
          }
      });

      scene.addEventListener('exit-vr', function () {
          arSessionActive = false;
          handTrackingActive = false;
          statusDiv.textContent = "AR session ended";
          canvasElement.style.opacity = "0";
      });

      scene.addEventListener('ar-hit-test-ready', function () {
          console.log("AR hit-test is ready");
          statusDiv.textContent = "Tap to place object. Hand tracking enabled.";
      });

      scene.addEventListener('ar-hit-test-start', function () {
          statusDiv.textContent = "Looking for surface...";
      });

      function adjustVideoCanvasSize() {
          const width = window.innerWidth;
          const height = window.innerHeight;
          
          canvasElement.style.width = width + 'px';
          canvasElement.style.height = height + 'px';
          canvasElement.width = width;
          canvasElement.height = height;
          
          videoElement.style.width = width + 'px';
          videoElement.style.height = height + 'px';
          videoElement.width = width;
          videoElement.height = height;
      }

      window.addEventListener('resize', adjustVideoCanvasSize);
      adjustVideoCanvasSize();
    </script>
  </body>
</html>


